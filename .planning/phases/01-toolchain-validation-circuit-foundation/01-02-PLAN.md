---
phase: 01-toolchain-validation-circuit-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - circuits/crates/shared_lib/Nargo.toml
  - circuits/crates/shared_lib/src/lib.nr
  - circuits/crates/shared_lib/src/credential.nr
  - circuits/crates/shared_lib/src/poseidon.nr
  - circuits/crates/shared_lib/src/schnorr.nr
  - circuits/crates/shared_lib/src/nullifier.nr
  - circuits/crates/trivial/Nargo.toml
  - circuits/crates/trivial/src/main.nr
  - circuits/crates/trivial/Prover.toml
  - scripts/package.json
  - scripts/tsconfig.json
  - scripts/issuer.ts
autonomous: true

must_haves:
  truths:
    - "shared_lib exports Poseidon2 hashing, Schnorr signature verification, nullifier derivation, and a Credential struct with 8 fields"
    - "A binary crate (trivial) can import and use shared_lib primitives and compiles successfully"
    - "nargo info shows constraint costs for shared_lib primitives and total is under 15K"
    - "The demo issuer script generates a Poseidon2-Schnorr keypair, hashes 8 credential fields with Poseidon2, signs the hash with Schnorr, and outputs a valid JSON file"
    - "Poseidon2 hash output from bb.js TypeScript matches the Noir circuit hash output for the same inputs"
  artifacts:
    - path: "circuits/crates/shared_lib/src/credential.nr"
      provides: "Credential struct with 8 fixed fields and hash method"
      contains: "struct Credential"
    - path: "circuits/crates/shared_lib/src/poseidon.nr"
      provides: "Poseidon2 hashing helpers for credentials and pubkeys"
      contains: "hash_credential_fields"
    - path: "circuits/crates/shared_lib/src/schnorr.nr"
      provides: "Schnorr signature verification wrapper for Grumpkin curve"
      contains: "verify_credential_signature"
    - path: "circuits/crates/shared_lib/src/nullifier.nr"
      provides: "Per-dApp nullifier derivation function"
      contains: "derive_nullifier"
    - path: "circuits/crates/shared_lib/src/lib.nr"
      provides: "Module declarations and re-exports for shared_lib"
      contains: "mod credential"
    - path: "scripts/issuer.ts"
      provides: "Demo credential issuer script"
      contains: "Barretenberg"
    - path: "scripts/package.json"
      provides: "Node dependencies for demo issuer"
      contains: "@aztec/bb.js"
  key_links:
    - from: "circuits/crates/shared_lib/src/credential.nr"
      to: "circuits/crates/shared_lib/src/poseidon.nr"
      via: "Credential.hash() calls poseidon2::hash()"
      pattern: "poseidon2::hash"
    - from: "circuits/crates/shared_lib/src/schnorr.nr"
      to: "circuits/crates/shared_lib/src/poseidon.nr"
      via: "Signature verified over Poseidon2-hashed credential"
      pattern: "message_hash"
    - from: "circuits/crates/trivial/src/main.nr"
      to: "circuits/crates/shared_lib/src/lib.nr"
      via: "dep::shared_lib import"
      pattern: "use dep::shared_lib"
    - from: "scripts/issuer.ts"
      to: "circuits/crates/shared_lib/src/credential.nr"
      via: "Same 8-field credential struct, same Poseidon2 hash, same Schnorr signature"
      pattern: "poseidon2Hash.*schnorrConstructSignature"
---

<objective>
Build the shared cryptographic library crate with all reusable primitives (Poseidon2 hashing, Schnorr verification, nullifier derivation, Credential struct) and create the demo credential issuer TypeScript script that generates signed test credentials compatible with the Noir circuits.

Purpose: The shared_lib is the foundation for ALL circuit crates in Phases 2-3. Every circuit will import these primitives. The demo issuer generates the test credentials needed for circuit development and end-to-end testing. Getting crypto compatibility right here (bb.js TypeScript Poseidon2 matching Noir Poseidon2) prevents silent failures in later phases.

Output: Complete shared_lib crate importable by binary crates, updated trivial circuit demonstrating shared_lib usage, demo credential JSON files, constraint budget measurements.
</objective>

<execution_context>
@/Users/laitsky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/laitsky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-toolchain-validation-circuit-foundation/01-RESEARCH.md
@.planning/phases/01-toolchain-validation-circuit-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build shared_lib crate with crypto primitives and measure constraints</name>
  <files>
    circuits/crates/shared_lib/src/lib.nr
    circuits/crates/shared_lib/src/credential.nr
    circuits/crates/shared_lib/src/poseidon.nr
    circuits/crates/shared_lib/src/schnorr.nr
    circuits/crates/shared_lib/src/nullifier.nr
    circuits/crates/trivial/Nargo.toml
    circuits/crates/trivial/src/main.nr
    circuits/crates/trivial/Prover.toml
  </files>
  <action>
    **1. Create `circuits/crates/shared_lib/src/credential.nr`:**
    Define the Credential struct with exactly 8 fields matching the project specification. Include a `hash()` method that computes Poseidon2 over all 8 fields. All field types are `Field` (BN254 scalar field elements).

    ```noir
    use dep::poseidon::poseidon2;

    pub struct Credential {
        pub subject_id: Field,
        pub issuer_id: Field,
        pub credential_type: Field,
        pub attribute_key: Field,
        pub attribute_value: Field,
        pub issued_at: Field,
        pub expires_at: Field,
        pub secret_salt: Field,
    }

    impl Credential {
        pub fn hash(self) -> Field {
            poseidon2::hash([
                self.subject_id,
                self.issuer_id,
                self.credential_type,
                self.attribute_key,
                self.attribute_value,
                self.issued_at,
                self.expires_at,
                self.secret_salt,
            ])
        }
    }
    ```

    **2. Create `circuits/crates/shared_lib/src/poseidon.nr`:**
    Convenience wrappers for Poseidon2 hashing used across the project.

    ```noir
    use dep::poseidon::poseidon2;

    // Hash 8 credential fields into a single commitment
    pub fn hash_credential_fields(fields: [Field; 8]) -> Field {
        poseidon2::hash(fields)
    }

    // Hash 2 fields (e.g., for nullifier or key derivation)
    pub fn hash_2(a: Field, b: Field) -> Field {
        poseidon2::hash([a, b])
    }

    // Hash 3 fields (e.g., for nullifier with context)
    pub fn hash_3(a: Field, b: Field, c: Field) -> Field {
        poseidon2::hash([a, b, c])
    }
    ```

    **3. Create `circuits/crates/shared_lib/src/schnorr.nr`:**
    Schnorr signature verification wrapper. Use the external `schnorr` library first. If the external lib adds no value over stdlib, fall back to `std::schnorr::verify_signature` directly (per research recommendation).

    ```noir
    use dep::schnorr;

    // Verify a Schnorr signature over a Poseidon2 message hash
    // The signature is 64 bytes (32-byte s + 32-byte e)
    // pub_key_x, pub_key_y are Grumpkin curve point coordinates
    pub fn verify_credential_signature(
        pub_key_x: Field,
        pub_key_y: Field,
        signature: [u8; 64],
        message_hash: Field,
    ) -> bool {
        let message_bytes: [u8; 32] = message_hash.to_be_bytes();
        schnorr::verify_signature(
            pub_key_x,
            pub_key_y,
            signature,
            message_bytes,
        )
    }
    ```

    NOTE: If `schnorr::verify_signature` does not exist as a direct export, try `dep::schnorr::verify_signature` or fall back to `std::schnorr::verify_signature`. The external lib may just re-export the stdlib function. Check the library source if compilation fails.

    ALSO NOTE: The `to_be_bytes` syntax may differ. If `message_hash.to_be_bytes::<32>()` is the correct syntax (turbofish), use that. If the compiler rejects it, try `message_hash.to_be_bytes()` or `let message_bytes: [u8; 32] = message_hash.to_be_bytes()`. The Noir beta.18 syntax may require explicit type annotation on the let binding instead of turbofish.

    **4. Create `circuits/crates/shared_lib/src/nullifier.nr`:**
    Per-dApp nullifier derivation. The nullifier is deterministic: same (secret_salt, credential_hash, dapp_context_id) always produces the same nullifier.

    ```noir
    use dep::poseidon::poseidon2;

    // Derive a per-dApp nullifier
    // nullifier = Poseidon2(secret_salt, credential_hash, dapp_context_id)
    // - Same user + same credential + same dApp = same nullifier (replay detection)
    // - Same user + same credential + different dApp = different nullifier (unlinkability)
    pub fn derive_nullifier(
        secret_salt: Field,
        credential_hash: Field,
        dapp_context_id: Field,
    ) -> Field {
        poseidon2::hash([secret_salt, credential_hash, dapp_context_id])
    }
    ```

    **5. Update `circuits/crates/shared_lib/src/lib.nr`:**
    ```noir
    mod credential;
    mod poseidon;
    mod schnorr;
    mod nullifier;

    use credential::Credential;
    ```

    **6. Update `circuits/crates/trivial/Nargo.toml` to depend on shared_lib:**
    Add `shared_lib = { path = "../shared_lib" }` to dependencies. Keep the direct `poseidon` dependency as well (trivial circuit may use it directly for the spike test).

    **7. Update `circuits/crates/trivial/src/main.nr` to exercise shared_lib:**
    Replace the minimal spike circuit with one that exercises the shared_lib primitives. This serves dual purpose: validates shared_lib is importable AND measures constraint costs.

    ```noir
    use dep::shared_lib::credential::Credential;
    use dep::shared_lib::schnorr::verify_credential_signature;
    use dep::shared_lib::nullifier::derive_nullifier;

    fn main(
        // Credential fields (private)
        subject_id: Field,
        issuer_id: Field,
        credential_type: Field,
        attribute_key: Field,
        attribute_value: Field,
        issued_at: Field,
        expires_at: Field,
        secret_salt: Field,
        // Signature (private)
        signature: [u8; 64],
        // Issuer public key (will be public in real circuits)
        pub_key_x: Field,
        pub_key_y: Field,
        // dApp context (public in real circuits)
        dapp_context_id: pub Field,
        // Expected outputs (public)
        expected_nullifier: pub Field,
    ) {
        // 1. Construct credential and hash it
        let credential = Credential {
            subject_id,
            issuer_id,
            credential_type,
            attribute_key,
            attribute_value,
            issued_at,
            expires_at,
            secret_salt,
        };
        let credential_hash = credential.hash();

        // 2. Verify issuer signature over credential hash
        let sig_valid = verify_credential_signature(
            pub_key_x,
            pub_key_y,
            signature,
            credential_hash,
        );
        assert(sig_valid, "Invalid issuer signature");

        // 3. Derive nullifier
        let nullifier = derive_nullifier(secret_salt, credential_hash, dapp_context_id);
        assert(nullifier == expected_nullifier, "Nullifier mismatch");
    }
    ```

    **8. Update `circuits/crates/trivial/Prover.toml`:**
    NOTE: Getting valid test values for this circuit requires a signed credential. The demo issuer (Task 2) will generate these. For now, create a Prover.toml with placeholder values. The circuit will NOT be provable yet -- only compilable. We verify compilability first, then prove after the issuer script is ready.

    Set all fields to `"0"` as placeholders:
    ```toml
    subject_id = "0"
    issuer_id = "0"
    credential_type = "0"
    attribute_key = "0"
    attribute_value = "0"
    issued_at = "0"
    expires_at = "0"
    secret_salt = "0"
    signature = ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0"]
    pub_key_x = "0"
    pub_key_y = "0"
    dapp_context_id = "0"
    expected_nullifier = "0"
    ```

    **9. Compile and measure constraints:**
    ```bash
    cd circuits && nargo build
    nargo info
    ```
    - `nargo build` must succeed (shared_lib is importable, all primitives compile)
    - `nargo info` shows constraint count. Record in the summary. Expected: ~10-15K constraints for Schnorr + Poseidon2(8) + Poseidon2(3) nullifier. Target: under 15K for shared_lib overhead.

    **10. If compilation fails:**
    - Check error messages carefully for import path issues (`dep::schnorr` vs `std::schnorr`)
    - Check `to_be_bytes` syntax (turbofish vs type annotation)
    - Check poseidon2::hash input format (array literal vs slice)
    - Fix and retry. Document any API differences from research in the summary.
  </action>
  <verify>
    1. `cd circuits && nargo build` exits 0 (shared_lib compiles, trivial circuit using shared_lib compiles)
    2. `nargo info` shows constraint count for the trivial circuit -- record the exact number
    3. Constraint count is under 15,000 (shared_lib overhead budget)
    4. All four modules exist: `ls circuits/crates/shared_lib/src/{credential,poseidon,schnorr,nullifier}.nr`
    5. `lib.nr` declares all four modules
  </verify>
  <done>
    shared_lib crate exports Credential struct (8 fields + hash method), Poseidon2 hashing helpers, Schnorr signature verification, and nullifier derivation. The trivial circuit imports and uses all shared_lib primitives and compiles successfully. Constraint count is measured and under 15K budget. The shared_lib is ready for Phase 2 (age_verify) and Phase 3 (membership_proof) circuits to depend on.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create demo credential issuer TypeScript script</name>
  <files>
    scripts/package.json
    scripts/tsconfig.json
    scripts/issuer.ts
  </files>
  <action>
    **1. Initialize scripts/ Node project:**
    ```bash
    mkdir -p scripts
    cd scripts
    npm init -y
    npm install @aztec/bb.js@3.0.0-nightly.20251104
    npm install -D typescript @types/node tsx
    ```

    Create `scripts/tsconfig.json`:
    ```json
    {
      "compilerOptions": {
        "target": "ESNext",
        "module": "ESNext",
        "moduleResolution": "bundler",
        "esModuleInterop": true,
        "strict": true,
        "outDir": "dist",
        "rootDir": ".",
        "declaration": true,
        "resolveJsonModule": true
      },
      "include": ["*.ts"]
    }
    ```

    Update `scripts/package.json` to add `"type": "module"` and a run script:
    ```json
    "type": "module",
    "scripts": {
      "issue": "npx tsx issuer.ts"
    }
    ```

    **2. Explore bb.js TypeScript types:**
    Before writing the issuer, inspect the actual API surface:
    ```bash
    cat node_modules/@aztec/bb.js/dest/barretenberg/index.d.ts | head -100
    ```
    Or search for specific methods:
    ```bash
    grep -r "schnorrComputePublicKey\|poseidon2Hash\|schnorrConstructSignature" node_modules/@aztec/bb.js/dest/
    ```

    Document the exact method signatures found. The research notes these methods exist but exact parameter types (Buffer vs BigInt vs Uint8Array) need confirmation from the `.d.ts` files.

    **3. Create `scripts/issuer.ts`:**
    The script must:
    a. Initialize Barretenberg WASM
    b. Generate a Schnorr keypair on the Grumpkin curve
    c. Define 8 credential fields as Field elements (BigInt or hex strings)
    d. Hash the 8 fields with Poseidon2 (MUST match Noir circuit hash)
    e. Sign the hash with Schnorr
    f. Output a JSON file with all credential data + signature + public key

    ```typescript
    import { Barretenberg, Fr } from '@aztec/bb.js';
    import { writeFileSync } from 'fs';
    import { randomBytes } from 'crypto';

    async function main() {
      // Initialize Barretenberg
      const bb = await Barretenberg.new();

      // Generate Schnorr keypair
      const privateKey = Buffer.from(randomBytes(32));
      const publicKey = await bb.schnorrComputePublicKey(privateKey);
      // NOTE: publicKey type may be [Fr, Fr] or { x: Fr, y: Fr } or Buffer
      // Adapt based on actual .d.ts types discovered in step 2

      // Credential fields (all as Fr / Field elements)
      const subjectId = Fr.random();
      const issuerId = new Fr(publicKey... /* derive from pubkey */);
      const credentialType = new Fr(0n); // 0 = age verification
      const attributeKey = new Fr(1n);   // 1 = "age" attribute
      const attributeValue = new Fr(25n); // age = 25
      const issuedAt = new Fr(BigInt(Math.floor(Date.now() / 1000)));
      const expiresAt = new Fr(BigInt(Math.floor(Date.now() / 1000) + 86400 * 365));
      const secretSalt = Fr.random();

      // Hash credential fields with Poseidon2
      // CRITICAL: This hash MUST match what the Noir circuit computes
      const credentialHash = await bb.poseidon2Hash([
        subjectId, issuerId, credentialType, attributeKey,
        attributeValue, issuedAt, expiresAt, secretSalt,
      ]);

      // Sign the hash with Schnorr
      const signature = await bb.schnorrConstructSignature(
        credentialHash.toBuffer(), // or similar -- adapt to actual API
        privateKey,
      );

      // Compute nullifier for a test dApp context
      const dappContextId = new Fr(42n); // test dApp ID
      const nullifier = await bb.poseidon2Hash([secretSalt, credentialHash, dappContextId]);

      // Output credential JSON
      const credential = {
        subject_id: subjectId.toString(),
        issuer_id: issuerId.toString(),
        credential_type: credentialType.toString(),
        attribute_key: attributeKey.toString(),
        attribute_value: attributeValue.toString(),
        issued_at: issuedAt.toString(),
        expires_at: expiresAt.toString(),
        secret_salt: secretSalt.toString(),
        signature: Array.from(signature), // [u8; 64] as number array
        issuer_pub_key_x: publicKey.x.toString(), // adapt to actual API
        issuer_pub_key_y: publicKey.y.toString(), // adapt to actual API
        credential_hash: credentialHash.toString(),
        nullifier: nullifier.toString(),
        dapp_context_id: dappContextId.toString(),
      };

      writeFileSync('demo_credential.json', JSON.stringify(credential, null, 2));
      console.log('Demo credential written to demo_credential.json');
      console.log(`Issuer public key: (${credential.issuer_pub_key_x}, ${credential.issuer_pub_key_y})`);
      console.log(`Credential hash: ${credential.credential_hash}`);
      console.log(`Nullifier (dApp 42): ${credential.nullifier}`);

      // Cleanup
      await bb.destroy();
    }

    main().catch(console.error);
    ```

    IMPORTANT ADAPTATION NOTES:
    - The code above is a TEMPLATE. The executor MUST inspect bb.js `.d.ts` types first and adapt parameter types accordingly.
    - If `Fr` is not directly importable from `@aztec/bb.js`, check for `Fr` in submodules or use raw `Buffer`/`BigInt` representations.
    - If `schnorrComputePublicKey` returns a Buffer instead of {x,y}, parse it according to the Grumpkin point encoding.
    - If `poseidon2Hash` expects a different input format (e.g., `Buffer[]` instead of `Fr[]`), convert accordingly.
    - The goal is a WORKING script, not exact code match. Adapt to what the API actually provides.

    **4. Run the issuer script:**
    ```bash
    cd scripts && npx tsx issuer.ts
    ```
    Verify: `demo_credential.json` is created with all fields populated.

    **5. Cross-validate Poseidon2 hash:**
    The credential hash computed by bb.js MUST match what the Noir circuit would compute. To validate:
    - Take the 8 field values from demo_credential.json
    - Create a Noir test in the trivial circuit that hashes these same 8 values and asserts the result matches the credential_hash from the JSON
    - Run `nargo test` to confirm match

    Add to `circuits/crates/trivial/src/main.nr` (or a separate test file):
    ```noir
    #[test]
    fn test_poseidon2_cross_validation() {
        // Paste field values from demo_credential.json here
        let fields: [Field; 8] = [
            /* subject_id */, /* issuer_id */, /* credential_type */,
            /* attribute_key */, /* attribute_value */, /* issued_at */,
            /* expires_at */, /* secret_salt */
        ];
        let expected_hash = /* credential_hash from JSON */;
        let computed_hash = dep::poseidon::poseidon2::hash(fields);
        assert(computed_hash == expected_hash);
    }
    ```
    Run: `cd circuits && nargo test`

    If the hashes do NOT match: this indicates a Poseidon2 parameter mismatch between bb.js and Noir. Debug by:
    - Hashing a single known value (e.g., [0]) in both and comparing
    - Checking if bb.js uses Poseidon2 vs Poseidon (different!)
    - Checking endianness of field element encoding
    This MUST be resolved before proceeding to Phase 2.

    **6. Generate Prover.toml from demo credential:**
    Update `circuits/crates/trivial/Prover.toml` with actual values from demo_credential.json so the updated trivial circuit (with shared_lib) can be proven end-to-end. Run `nargo execute witness && bb prove` to confirm the full pipeline still works with real credential data.

    **7. Create a second demo credential (membership type):**
    Run the issuer again with modified parameters (credential_type = 1, attribute_key = membership group) to have test data for Phase 3 as well. Save as `demo_credential_membership.json`.
  </action>
  <verify>
    1. `cd scripts && npx tsx issuer.ts` exits 0 and creates `demo_credential.json`
    2. `demo_credential.json` contains all fields: subject_id, issuer_id, credential_type, attribute_key, attribute_value, issued_at, expires_at, secret_salt, signature (64 bytes), issuer_pub_key_x, issuer_pub_key_y, credential_hash, nullifier, dapp_context_id
    3. `cd circuits && nargo test` passes -- Poseidon2 cross-validation test confirms TypeScript and Noir produce the same hash for the same inputs
    4. Updated Prover.toml with real credential data allows `nargo execute witness` to succeed
    5. `bb prove` and `bb verify` succeed with the credential-based witness (full pipeline with real data)
  </verify>
  <done>
    The demo credential issuer script generates Poseidon2-Schnorr signed credentials as JSON (DEMO-01 requirement satisfied). Poseidon2 hash compatibility between TypeScript (bb.js) and Noir is confirmed via cross-validation test. At least two demo credential files exist (age type + membership type) for use in Phases 2-3. The trivial circuit with shared_lib primitives produces a valid proof from real credential data, confirming the full pipeline works with actual crypto operations.
  </done>
</task>

</tasks>

<verification>
Phase 1, Plan 02 is complete when:
1. shared_lib crate has 4 modules (credential, poseidon, schnorr, nullifier) and compiles as a library
2. The trivial circuit imports shared_lib, uses all primitives, and compiles under 15K constraints
3. The demo issuer script runs and produces valid credential JSON files
4. Poseidon2 cross-validation test passes (TypeScript hash == Noir hash for same inputs)
5. The full pipeline (compile -> prove -> verify) works with real credential data
6. Constraint budget is documented (CIRC-08 baseline established)
</verification>

<success_criteria>
- `nargo build` succeeds for the workspace including shared_lib and trivial circuit
- `nargo info` shows constraint count under 15,000 for the trivial circuit using shared_lib
- `nargo test` passes with Poseidon2 cross-validation test
- `npx tsx scripts/issuer.ts` generates valid `demo_credential.json`
- `demo_credential.json` values produce a valid proof when used in the trivial circuit
- Requirements CIRC-07 (shared library), CIRC-08 (constraint budget baseline), and DEMO-01 (demo issuer) are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-toolchain-validation-circuit-foundation/01-02-SUMMARY.md`
</output>
