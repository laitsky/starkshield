---
phase: 03-membership-verification-circuit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - circuits/Nargo.toml
  - circuits/crates/membership_proof/Nargo.toml
  - circuits/crates/membership_proof/src/main.nr
  - circuits/crates/membership_proof/Prover.toml
  - scripts/issuer.ts

autonomous: true

must_haves:
  truths:
    - "A signed membership credential with attribute_value in the allowed_set produces a valid proof"
    - "A signed membership credential with attribute_value NOT in the allowed_set fails to produce a proof"
    - "An expired membership credential is rejected regardless of set membership"
    - "A forged signature is rejected regardless of set membership"
    - "A credential with attribute_value = 0 is rejected (prevents zero-padding false matches)"
    - "Different dapp_context_ids produce different nullifiers for the same credential"
    - "Both age_verify and membership_proof compile and pass all tests in the same workspace"
    - "Both circuits have fewer than 50K ACIR opcodes each"
  artifacts:
    - path: "circuits/crates/membership_proof/src/main.nr"
      provides: "Membership verification circuit with set membership check, signature verification, expiration, nullifier"
      contains: "fn main"
    - path: "circuits/crates/membership_proof/Nargo.toml"
      provides: "Binary crate configuration with shared_lib and poseidon dependencies"
      contains: "membership_proof"
    - path: "circuits/crates/membership_proof/Prover.toml"
      provides: "Default witness inputs with membership credential and allowed_set"
      contains: "allowed_set"
    - path: "circuits/Nargo.toml"
      provides: "Workspace with membership_proof added to members"
      contains: "membership_proof"
  key_links:
    - from: "circuits/crates/membership_proof/src/main.nr"
      to: "circuits/crates/shared_lib/src/lib.nr"
      via: "use dep::shared_lib imports"
      pattern: "shared_lib::credential::Credential"
    - from: "circuits/crates/membership_proof/src/main.nr"
      to: "circuits/crates/shared_lib/src/schnorr.nr"
      via: "assert_credential_signature call"
      pattern: "assert_credential_signature"
    - from: "circuits/crates/membership_proof/src/main.nr"
      to: "circuits/crates/shared_lib/src/nullifier.nr"
      via: "derive_nullifier call"
      pattern: "derive_nullifier"
    - from: "scripts/issuer.ts"
      to: "circuits/crates/membership_proof/Prover.toml"
      via: "generateProverToml membership branch"
      pattern: "allowed_set"
---

<objective>
Build the membership_proof Noir circuit that proves set membership without revealing which member matched, mirroring the age_verify circuit structure exactly. Validate the full bb prove/verify pipeline and document public output ordering.

Purpose: Second credential type proves protocol generality -- StarkShield handles multiple credential types (age, membership) with the same security guarantees (signatures, expiration, nullifiers).

Output: Compiled membership_proof circuit, passing Noir tests, validated bb pipeline, documented public output ordering, updated issuer.ts for membership Prover.toml generation.
</objective>

<execution_context>
@/Users/laitsky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/laitsky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-membership-verification-circuit/03-RESEARCH.md
@.planning/phases/02-age-verification-circuit/02-01-SUMMARY.md

# Key source files to reference during implementation
@circuits/crates/age_verify/src/main.nr
@circuits/crates/age_verify/Nargo.toml
@circuits/Nargo.toml
@scripts/issuer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create membership_proof circuit crate with Noir tests and update issuer.ts</name>
  <files>
    circuits/crates/membership_proof/Nargo.toml
    circuits/crates/membership_proof/src/main.nr
    circuits/crates/membership_proof/Prover.toml
    circuits/Nargo.toml
    scripts/issuer.ts
  </files>
  <action>
    Create the membership_proof circuit by mirroring the age_verify circuit structure exactly, changing only the domain-specific check (set membership instead of age threshold).

    **Step 1: Create crate structure**
    - Create `circuits/crates/membership_proof/Nargo.toml` -- copy from age_verify, change package name to "membership_proof". Same deps: poseidon v0.2.3, shared_lib path dep.
    - Update `circuits/Nargo.toml` workspace members to include "crates/membership_proof" (keep default-member as age_verify).

    **Step 2: Generate a fresh membership credential for test fixtures**
    - Run `cd scripts && npx tsx issuer.ts --type membership` to generate a membership credential with credential_type=1, attribute_key=2, attribute_value=100 (group ID).
    - Extract the hex values from the output JSON to use as test constants in main.nr and as Prover.toml values.

    **Step 3: Create the circuit (`circuits/crates/membership_proof/src/main.nr`)**
    - Copy the structure from `circuits/crates/age_verify/src/main.nr` exactly.
    - Same private witness: 8 credential fields + signature [u8; 64].
    - Change public inputs: replace `threshold: pub Field` with `allowed_set: pub [Field; 8]`. Keep pub_key_x, pub_key_y, current_timestamp, dapp_context_id.
    - Same return type: `-> pub (Field, Field, Field, Field)` returning (nullifier, issuer_pub_key_x, attribute_key, allowed_set_hash).
    - Same shared_lib imports: Credential, assert_credential_signature, derive_nullifier.
    - Add `use dep::poseidon::poseidon2::Poseidon2;` for hashing the allowed_set.
    - Implementation body:
      1. Construct Credential struct and compute hash (identical to age_verify)
      2. assert_credential_signature (identical)
      3. Expiration check: `assert(ts < exp, "Credential has expired")` (identical)
      4. NEW: Zero-value guard: `assert(attribute_value != 0, "Attribute value cannot be zero")`
      5. NEW: Set membership check via for-loop:
         ```
         let mut found: bool = false;
         for i in 0..8 {
             if allowed_set[i] == attribute_value {
                 found = true;
             }
         }
         assert(found, "Attribute value not in allowed set");
         ```
      6. NEW: Hash allowed_set: `let allowed_set_hash = Poseidon2::hash(allowed_set, 8);`
      7. Derive nullifier (identical to age_verify)
      8. Return (nullifier, pub_key_x, attribute_key, allowed_set_hash)

    **Step 4: Write tests in main.nr (same pattern as age_verify)**
    Use the freshly generated membership credential values from Step 2 as test constants.

    Tests to implement:
    1. `test_valid_membership_verification` -- Valid credential with attribute_value=100, allowed_set includes 100. Assert nullifier matches expected, assert echoed pub_key_x and attribute_key match.
    2. `test_expired_credential_rejected` -- Same credential but current_timestamp >= expires_at. `#[test(should_fail_with = "Credential has expired")]`
    3. `test_value_not_in_set_rejected` -- Valid credential but change allowed_set to exclude attribute_value (e.g., all zeros or different values). `#[test(should_fail_with = "Attribute value not in allowed set")]`. Note: Cannot just change attribute_value because signature would be invalid. Instead, keep the credential intact but change the allowed_set public input to [200, 300, 400, 0, 0, 0, 0, 0] which does not include 100.
    4. `test_wrong_signature_rejected` -- Tamper one signature byte. `#[test(should_fail)]`
    5. `test_zero_attribute_value_rejected` -- This requires a credential signed with attribute_value=0. Since we cannot easily create one inside Noir tests, use the derive_nullifier function directly to test the zero guard: create a separate test that calls main() with attribute_value=0 in the credential struct. The signature will be invalid, so this will fail at the signature check before reaching the zero check. Alternative approach: just assert the logic by testing the circuit would reject a zero value if it somehow passed signature check. Best approach: Skip this test if it requires a new credential -- the assert(attribute_value != 0) line is self-evident, and a test with a mismatched signature would fail on signature, not on the zero check. Document that the zero-guard is a defense-in-depth measure.
    6. `test_different_context_different_nullifier` -- Two different dapp_context_ids produce different nullifiers (reuse derive_nullifier directly, same as age_verify).
    7. `test_same_context_same_nullifier` -- Same inputs produce same nullifier (identical to age_verify).

    **Step 5: Create Prover.toml**
    - Use the values from the generated membership credential.
    - Include `allowed_set` as a TOML array of 8 hex Field values: the credential's attribute_value (100 = 0x64) plus 2-3 other group IDs, zero-padded to 8 elements.
    - Include pub_key_x, pub_key_y, current_timestamp (use issued_at value, which is before expires_at), dapp_context_id = 42 (0x2a).

    **Step 6: Update issuer.ts generateProverToml**
    - Modify `generateProverToml` to accept a second parameter `isMembership: boolean`.
    - When `isMembership` is true: output `allowed_set` instead of `threshold`. The allowed_set should include the credential's attribute_value plus additional placeholder group IDs (200, 300), zero-padded to 8 elements.
    - When `isMembership` is false: keep current behavior (output `threshold`).
    - Update the call site in main() to pass the `isMembership` flag.

    **Step 7: Compile and test**
    - Run `cd circuits && nargo build --package membership_proof` -- must succeed.
    - Run `cd circuits && nargo test --package membership_proof` -- all tests must pass.
    - Run `cd circuits && nargo test` -- workspace-wide, both age_verify and membership_proof tests must pass.
  </action>
  <verify>
    ```bash
    cd circuits && nargo build --package membership_proof
    cd circuits && nargo test --package membership_proof
    cd circuits && nargo test  # workspace-wide: both circuits pass
    ```
    All three commands exit 0. No test failures.
  </verify>
  <done>
    membership_proof circuit compiles, all Noir tests pass (valid membership, expired rejection, not-in-set rejection, wrong signature rejection, nullifier determinism), and workspace-wide build + test succeeds with both age_verify and membership_proof.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate full bb prove/verify pipeline and document public output ordering</name>
  <files>
    circuits/crates/membership_proof/src/main.nr
  </files>
  <action>
    Run the complete bb prove/verify pipeline for the membership_proof circuit and document the public output ordering empirically.

    **Step 1: Generate witness**
    ```bash
    cd circuits && nargo execute --package membership_proof
    ```
    This produces `target/membership_proof.gz` (witness) and `target/membership_proof.json` (ACIR artifact).

    **Step 2: Write verification key**
    ```bash
    cd circuits && bb write_vk -s ultra_honk --oracle_hash keccak \
      -b target/membership_proof.json -o target/membership_proof_vk
    ```

    **Step 3: Generate proof**
    ```bash
    cd circuits && bb prove -s ultra_honk --oracle_hash keccak \
      -b target/membership_proof.json -w target/membership_proof.gz \
      -k target/membership_proof_vk/vk -o target/membership_proof_proof
    ```

    **Step 4: Verify proof**
    ```bash
    cd circuits && bb verify -s ultra_honk --oracle_hash keccak \
      -k target/membership_proof_vk/vk \
      -p target/membership_proof_proof/proof \
      -i target/membership_proof_proof/public_inputs
    ```
    Must print "Proof verified successfully" and exit 0.

    **Step 5: Document public output ordering**
    - Read the public_inputs file (hex values, one per line or space-separated).
    - Map each value to its source by comparing against the Prover.toml inputs and expected return values.
    - Expected ordering (following the established pattern from age_verify: pub params first in declaration order, then return values in tuple order):
      - pub_key_x, pub_key_y, current_timestamp, dapp_context_id (4 scalar pub params)
      - allowed_set[0] through allowed_set[7] (8 array elements)
      - nullifier (return value 1)
      - issuer_pub_key_x (return value 2)
      - attribute_key (return value 3)
      - allowed_set_hash (return value 4)
    - Total expected: 16 public fields (4 scalar params + 8 array elements + 4 return values).
    - Add a documentation comment block at the top of main.nr documenting the exact ordering, matching the style of age_verify's comment block.

    **Step 6: Check constraint counts for both circuits**
    ```bash
    cd circuits && nargo info --package membership_proof
    cd circuits && nargo info --package age_verify
    ```
    Both must be under 50,000 ACIR opcodes. Expected: membership_proof ~1,300-1,500, age_verify 1,224.
    Document the actual membership_proof constraint count in the main.nr header comment.
  </action>
  <verify>
    ```bash
    cd circuits && nargo execute --package membership_proof
    cd circuits && bb write_vk -s ultra_honk --oracle_hash keccak -b target/membership_proof.json -o target/membership_proof_vk
    cd circuits && bb prove -s ultra_honk --oracle_hash keccak -b target/membership_proof.json -w target/membership_proof.gz -k target/membership_proof_vk/vk -o target/membership_proof_proof
    cd circuits && bb verify -s ultra_honk --oracle_hash keccak -k target/membership_proof_vk/vk -p target/membership_proof_proof/proof -i target/membership_proof_proof/public_inputs
    cd circuits && nargo info --package membership_proof
    cd circuits && nargo info --package age_verify
    ```
    bb verify prints "Proof verified successfully". Both nargo info outputs show ACIR opcodes < 50,000.
  </verify>
  <done>
    Full bb prove/verify pipeline succeeds for membership_proof circuit. Public output ordering documented empirically in main.nr header comment. Both circuits confirmed under 50K ACIR opcodes via nargo info.
  </done>
</task>

</tasks>

<verification>
1. `cd circuits && nargo test` -- all tests pass for both age_verify and membership_proof
2. `cd circuits && nargo info --package membership_proof` -- ACIR opcodes < 50,000
3. `cd circuits && nargo info --package age_verify` -- ACIR opcodes < 50,000 (should still be 1,224)
4. bb verify succeeds for membership_proof proof
5. Public output ordering documented in membership_proof/src/main.nr header comment
6. `scripts/issuer.ts --type membership` generates Prover.toml with allowed_set field
</verification>

<success_criteria>
- membership_proof circuit accepts a signed membership credential and proves attribute_value is in allowed_set without revealing which element matched
- Expired credentials, forged signatures, and values not in the set are all rejected by hard-assert
- Zero attribute_value is guarded against (prevents false match on zero-padded array slots)
- Both circuits compile and pass all tests in the same workspace
- Both circuits have fewer than 50K ACIR opcodes (membership_proof expected ~1,300-1,500)
- Full bb prove/verify pipeline produces and verifies a valid membership proof
- Public output ordering empirically documented for Phase 4 contract integration
</success_criteria>

<output>
After completion, create `.planning/phases/03-membership-verification-circuit/03-01-SUMMARY.md`
</output>
