---
phase: 04-smart-contracts-deployment
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - contracts/src/lib.cairo
  - contracts/src/registry.cairo
  - contracts/src/ownable.cairo
  - contracts/Scarb.toml
  - contracts/tests/test_registry.cairo
  - deployments.json
autonomous: false
user_setup: []

must_haves:
  truths:
    - "verify_and_register() accepts a proof, routes to the correct verifier by circuit_id, rejects used nullifiers, and emits VerificationPassed event"
    - "Trusted issuers can be added/removed by owner, and proofs with non-trusted issuer_pub_key_x are rejected"
    - "Verification records are queryable on-chain by nullifier"
    - "StarkShieldRegistry is deployed on Starknet Sepolia with both verifier addresses wired in"
    - "A full verify_and_register transaction costs less than 500,000 gas units (or gas cost is documented if exceeded)"
  artifacts:
    - path: "contracts/src/registry.cairo"
      provides: "StarkShieldRegistry contract with verify_and_register, nullifier tracking, issuer management, event emission"
      contains: "fn verify_and_register"
    - path: "contracts/src/ownable.cairo"
      provides: "Simple owner-only access control (hand-rolled, no OpenZeppelin)"
      contains: "fn assert_only_owner"
    - path: "contracts/tests/test_registry.cairo"
      provides: "Integration tests for registry logic"
      contains: "fn test_"
    - path: "deployments.json"
      provides: "All deployed contract addresses (verifiers + registry)"
      contains: "registry"
  key_links:
    - from: "contracts/src/registry.cairo"
      to: "contracts_age_verifier (deployed)"
      via: "IUltraKeccakZKHonkVerifierDispatcher call"
      pattern: "IUltraKeccakZKHonkVerifierDispatcher"
    - from: "contracts/src/registry.cairo"
      to: "contracts/src/ownable.cairo"
      via: "assert_only_owner import"
      pattern: "assert_only_owner"
    - from: "contracts/src/registry.cairo"
      to: "public_inputs index extraction"
      via: "age nullifier at index 5, membership nullifier at index 12"
      pattern: "public_inputs\\.at\\((5|12)\\)"
---

<objective>
Build the StarkShieldRegistry Cairo contract with verify_and_register() routing, nullifier tracking, trusted issuer management, verification logging, and event emission. Test with snforge, then deploy to Starknet Sepolia with the verifier addresses from Plan 01.

Purpose: The registry is the single entry point for all proof verification on StarkShield. It routes proofs to the correct circuit verifier, enforces business rules (nullifier uniqueness, issuer trust), and creates an on-chain verification log queryable by dApps.

Output: StarkShieldRegistry deployed on Sepolia, wired to both verifiers, with all business logic (CONT-02 through CONT-07) implemented and tested.
</objective>

<execution_context>
@/Users/laitsky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/laitsky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-smart-contracts-deployment/04-RESEARCH.md
@.planning/phases/04-smart-contracts-deployment/04-01-SUMMARY.md
@deployments.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build StarkShieldRegistry contract with full business logic</name>
  <files>
    contracts/src/registry.cairo
    contracts/src/ownable.cairo
    contracts/src/lib.cairo
    contracts/Scarb.toml
  </files>
  <action>
    Build the StarkShieldRegistry contract that wraps both Garaga verifiers with business logic. This is the hand-written contract -- do NOT modify any Garaga-generated files.

    **Step 1: Create ownable.cairo**
    Simple owner-only access control module. Do NOT use OpenZeppelin (incompatible with Scarb 2.14.0 per research). Hand-roll 3 functions:
    - `assert_only_owner(owner: ContractAddress)` -- asserts get_caller_address() == owner
    This is intentionally minimal -- just an assertion function used by the registry.

    **Step 2: Create registry.cairo**
    The StarkShieldRegistry contract with these components:

    **Interface (IStarkShieldRegistry trait):**
    - `verify_and_register(ref self, circuit_id: u8, full_proof_with_hints: Span<felt252>)` -- main entry point
    - `is_nullifier_used(self, nullifier: u256) -> bool`
    - `get_verification_record(self, nullifier: u256) -> VerificationRecord`
    - `add_trusted_issuer(ref self, issuer_pub_key_x: u256)`
    - `remove_trusted_issuer(ref self, issuer_pub_key_x: u256)`
    - `is_trusted_issuer(self, issuer_pub_key_x: u256) -> bool`

    **Verifier interface (inline, matches Garaga-generated contract):**
    ```cairo
    #[starknet::interface]
    pub trait IUltraKeccakZKHonkVerifier<TContractState> {
        fn verify_ultra_keccak_zk_honk_proof(
            self: @TContractState, full_proof_with_hints: Span<felt252>,
        ) -> Result<Span<u256>, felt252>;
    }
    ```

    **Storage:**
    - `owner: ContractAddress`
    - `verifiers: Map<u8, ContractAddress>` -- circuit_id to verifier address
    - `trusted_issuers: Map<u256, bool>` -- issuer_pub_key_x to is_trusted
    - `nullifier_used: Map<u256, bool>` -- nullifier to is_used
    - `verification_records: Map<u256, VerificationRecord>` -- nullifier to record

    **VerificationRecord struct** (derives Drop, Copy, Serde, starknet::Store):
    - nullifier: u256
    - attribute_key: u256
    - threshold_or_set_hash: u256
    - timestamp: u64
    - circuit_id: u8

    **Events:**
    - `VerificationPassed { #[key] nullifier: u256, attribute_key: u256, threshold_or_set_hash: u256, timestamp: u64, circuit_id: u8 }`
    - `TrustedIssuerAdded { #[key] issuer_pub_key_x: u256 }`
    - `TrustedIssuerRemoved { #[key] issuer_pub_key_x: u256 }`

    **Constructor:**
    `constructor(ref self, owner: ContractAddress, age_verifier: ContractAddress, membership_verifier: ContractAddress)`
    - Writes owner, sets verifiers.entry(0) = age_verifier, verifiers.entry(1) = membership_verifier

    **verify_and_register implementation (CRITICAL -- most complex function):**
    1. Look up verifier address: `self.verifiers.entry(circuit_id).read()`. Assert it is not zero (invalid circuit_id).
    2. Create dispatcher: `IUltraKeccakZKHonkVerifierDispatcher { contract_address: verifier_addr }`
    3. Call `verify_ultra_keccak_zk_honk_proof(full_proof_with_hints)`. Match Result: Ok(public_inputs) or Err -> panic.
    4. Extract fields by circuit_id:
       - **circuit_id 0 (age_verify, 9 public inputs):**
         - nullifier = public_inputs.at(5)
         - issuer_pub_key_x = public_inputs.at(6)
         - attribute_key = public_inputs.at(7)
         - threshold_or_set_hash = public_inputs.at(8)  (threshold)
       - **circuit_id 1 (membership_proof, 16 public inputs):**
         - nullifier = public_inputs.at(12)
         - issuer_pub_key_x = public_inputs.at(13)
         - attribute_key = public_inputs.at(14)
         - threshold_or_set_hash = public_inputs.at(15)  (allowed_set_hash)
    5. Assert issuer is trusted: `assert(self.trusted_issuers.entry(*issuer_pub_key_x).read(), 'Issuer not trusted')`
    6. Assert nullifier not used: `assert(!self.nullifier_used.entry(*nullifier).read(), 'Nullifier already used')`
    7. Mark nullifier as used: `self.nullifier_used.entry(*nullifier).write(true)`
    8. Create and store VerificationRecord with get_block_timestamp()
    9. Emit VerificationPassed event

    **Owner-only functions (add/remove trusted issuer):**
    Call `assert_only_owner(self.owner.read())` at the start. Then write to trusted_issuers map and emit event.

    **Step 3: Update lib.cairo**
    The existing lib.cairo declares the Garaga-generated modules. The registry is a SEPARATE contract in the same Scarb project. Update lib.cairo to declare all modules:
    ```cairo
    pub mod honk_verifier;
    pub mod honk_verifier_circuits;
    pub mod honk_verifier_constants;
    pub mod registry;
    pub mod ownable;
    ```
    NOTE: The honk_verifier* modules in `contracts/src/` are from the trivial circuit (Phase 1). They will NOT be used for verification (the real verifiers are in contracts_age_verifier and contracts_membership_verifier, already deployed). But they must remain for the project to compile. The registry contract calls EXTERNAL verifier contracts via dispatchers (by deployed address), NOT the local honk_verifier module.

    **Step 4: Update Scarb.toml if needed**
    Ensure Scarb.toml has the correct dependencies (starknet, garaga, snforge_std). The existing Scarb.toml from Phase 1 should already be correct. Verify it includes:
    - `starknet = "2.14.0"`
    - `garaga` git dependency
    - `snforge_std = "0.53.0"` in dev-dependencies

    **Step 5: Compile**
    Run `cd contracts && scarb build` and confirm exit 0. Fix any compilation errors.

    **CRITICAL pitfall avoidance:**
    - Public input indices are the MOST DANGEROUS part. Double-check against circuit source: age_verify nullifier at index 5, membership_proof nullifier at index 12. Getting this wrong means reading wrong data silently.
    - Use `*public_inputs.at(N)` (dereference the snapshot) to get u256 values from the Span
    - Do NOT import OpenZeppelin -- hand-roll Ownable as described
    - The verifier dispatcher returns `Result<Span<u256>, felt252>` -- handle both cases
    - Storage imports: `use starknet::storage::{Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess};`
  </action>
  <verify>
    1. `cd contracts && scarb build` exits 0
    2. `contracts/src/registry.cairo` exists and contains `fn verify_and_register`
    3. `contracts/src/ownable.cairo` exists and contains `fn assert_only_owner`
    4. `contracts/src/lib.cairo` declares `registry` and `ownable` modules
  </verify>
  <done>
    StarkShieldRegistry contract compiles successfully with verify_and_register routing (circuit_id 0 for age, 1 for membership), nullifier tracking, trusted issuer management (add/remove with owner-only), verification record storage, and VerificationPassed event emission.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test registry with snforge, deploy to Sepolia, and validate end-to-end</name>
  <files>
    contracts/tests/test_registry.cairo
    deployments.json
  </files>
  <action>
    Write snforge tests for the Registry's business logic, then declare, deploy, and validate on Sepolia.

    **Step 1: Generate calldata fixtures for tests**
    Generate snforge-format calldata for both circuits using garaga calldata CLI:
    ```bash
    source .venv/bin/activate
    garaga calldata \
      --system ultra_keccak_zk_honk \
      --proof circuits/target/age_verify_proof/proof \
      --vk circuits/target/age_verify_vk/vk \
      --format array \
      --output-path contracts/tests/calldata_age.txt

    garaga calldata \
      --system ultra_keccak_zk_honk \
      --proof circuits/target/membership_proof_proof/proof \
      --vk circuits/target/membership_proof_vk/vk \
      --format array \
      --output-path contracts/tests/calldata_membership.txt
    ```
    NOTE: The `--format` options may be `starkli`, `array`, or `snforge`. Try `--format array` first. If the format does not work for snforge tests, try `--format snforge` or check `garaga calldata --help` for available formats. The calldata is a large array of felt252 values representing the proof + hints.

    **Step 2: Write test_registry.cairo**
    Create integration tests covering:

    a) **test_owner_can_add_trusted_issuer** -- Deploy registry, call add_trusted_issuer as owner, verify is_trusted_issuer returns true.

    b) **test_non_owner_cannot_add_trusted_issuer** -- Deploy registry, call add_trusted_issuer as non-owner, expect panic with 'Caller is not the owner'.

    c) **test_owner_can_remove_trusted_issuer** -- Add then remove an issuer, verify is_trusted_issuer returns false.

    d) **test_nullifier_not_used_initially** -- Deploy registry, check is_nullifier_used for random nullifier returns false.

    For the test setup, use snforge's `declare` and `deploy` pattern:
    ```cairo
    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};
    use snforge_std::cheatcodes::contract_class::ContractClass;
    use snforge_std::start_cheat_caller_address;
    ```

    Deploy the registry with mock addresses for the verifiers (the business logic tests do not need real verifier contracts -- only the trusted issuer and nullifier tests need the registry itself).

    NOTE: Full end-to-end verification tests (calling verify_and_register with real proofs) require the verifier contracts to be declared on the fork network. This is complex to set up in snforge fork mode. Prioritize testing the business logic (issuer management, nullifier checks) in unit tests. The end-to-end verification is validated via CLI after deployment (Step 4).

    **Step 3: Run tests**
    ```bash
    cd contracts && snforge test
    ```
    All tests must pass. If `start_cheat_caller_address` API differs in snforge_std 0.53.0, check the error message and adapt the import/call signature.

    **Step 4: Declare and deploy StarkShieldRegistry on Sepolia**
    Use sncast (not garaga -- garaga is for verifier contracts only):
    ```bash
    cd contracts
    sncast --account sepolia declare \
      --contract-name StarkShieldRegistry \
      --network sepolia
    ```
    NOTE: If sncast account is not yet set up, create one:
    ```bash
    sncast account create --network sepolia --name sepolia --type oz
    # OR add existing account:
    sncast account add --name sepolia --address <ACCOUNT_ADDRESS> --private-key <PRIVATE_KEY> --type oz
    ```

    Then deploy with constructor args (read verifier addresses from deployments.json):
    ```bash
    sncast --account sepolia deploy \
      --class-hash <REGISTRY_CLASS_HASH> \
      --constructor-calldata <OWNER_ADDR> <AGE_VERIFIER_ADDR> <MEMBERSHIP_VERIFIER_ADDR> \
      --network sepolia
    ```
    Constructor takes 3 ContractAddress values = 3 felt252 values in calldata.

    If sncast is problematic, fall back to using starkli or a simple deployment script. The key is getting the contract deployed with the correct constructor args.

    **Step 5: Add trusted issuer on-chain**
    After deployment, add the demo credential issuer's public key as a trusted issuer:
    ```bash
    sncast --account sepolia invoke \
      --contract-address <REGISTRY_ADDRESS> \
      --function add_trusted_issuer \
      --calldata <ISSUER_PUB_KEY_X_LOW> <ISSUER_PUB_KEY_X_HIGH> \
      --network sepolia
    ```
    The issuer_pub_key_x is a u256, serialized as two felt252 (low, high). Get the value from the demo credential JSON or from the Prover.toml files.

    **Step 6: Validate full verify_and_register flow**
    Generate calldata for a proof submission and invoke verify_and_register:
    ```bash
    # Generate calldata for age_verify proof
    garaga calldata \
      --system ultra_keccak_zk_honk \
      --proof circuits/target/age_verify_proof/proof \
      --vk circuits/target/age_verify_vk/vk \
      --format starkli

    # Call verify_and_register with circuit_id=0 (age) and the proof calldata
    sncast --account sepolia invoke \
      --contract-address <REGISTRY_ADDRESS> \
      --function verify_and_register \
      --calldata 0 <PROOF_CALLDATA...> \
      --network sepolia
    ```
    NOTE: The calldata format for sncast invoke may need adjustment. The first argument is circuit_id (0 for age), followed by the proof_with_hints array. The array needs to be prefixed with its length in felt252 format per Cairo serialization rules.

    If direct sncast invocation is complex, use garaga verify-onchain against the individual verifiers (already validated in Plan 01) and test the registry's business logic through snforge tests instead. The key is that the contract is deployed and the business logic works.

    **Step 7: Update deployments.json**
    Add the registry contract address:
    ```json
    {
      "network": "sepolia",
      "age_verifier": { "class_hash": "0x...", "contract_address": "0x..." },
      "membership_verifier": { "class_hash": "0x...", "contract_address": "0x..." },
      "registry": { "class_hash": "0x...", "contract_address": "0x..." }
    }
    ```

    **Step 8: Record gas costs**
    Note the gas consumed by the verify_and_register transaction (from the transaction receipt). Compare against the 500K target (CONT-07). If the verification + registry overhead exceeds 500K, document the actual cost in the summary. The Garaga verifier is the dominant cost -- the registry adds minimal overhead (a few storage writes + event).
  </action>
  <verify>
    1. `cd contracts && snforge test` passes (business logic tests)
    2. `deployments.json` contains registry contract address
    3. Registry is deployed on Sepolia (visible on Starkscan)
    4. Trusted issuer was added successfully (invoke transaction confirmed)
  </verify>
  <done>
    StarkShieldRegistry is deployed on Starknet Sepolia with both verifier addresses wired in. Business logic tests pass (issuer management, nullifier checks). Trusted demo issuer is registered. deployments.json contains all three contract addresses. Gas cost is documented.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify full on-chain infrastructure on Sepolia</name>
  <what-built>
    Complete on-chain verification infrastructure on Starknet Sepolia:
    1. Age verify HonkVerifier contract (Garaga-generated)
    2. Membership proof HonkVerifier contract (Garaga-generated)
    3. StarkShieldRegistry contract with verify_and_register(), nullifier tracking, trusted issuer management, and VerificationPassed events
    All three contracts deployed and wired together.
  </what-built>
  <how-to-verify>
    1. Open `deployments.json` and note all three contract addresses
    2. Visit https://sepolia.starkscan.co/ and search for the registry contract address -- confirm it is deployed
    3. Check the Events tab on Starkscan for TrustedIssuerAdded event (from the add_trusted_issuer invoke)
    4. If a verify_and_register transaction was executed, check for VerificationPassed event and note gas consumed
    5. Confirm the total verify_and_register gas cost relative to the 500K target (CONT-07)
    6. Verify `.secrets` is NOT in git: `git status` should not show .secrets as tracked
  </how-to-verify>
  <resume-signal>Type "approved" with gas cost notes, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Phase 4 verification checklist:
- CONT-01: Garaga-generated HonkVerifier deployed on Sepolia, verifies proofs via CLI -- checked in Plan 01
- CONT-02: StarkShieldRegistry with trusted_issuers mapping, owner add/remove -- checked in Task 1-2
- CONT-03: Nullifier tracking, reject previously-seen nullifiers -- implemented in verify_and_register
- CONT-04: Verification records stored by nullifier, queryable via get_verification_record -- implemented
- CONT-05: VerificationPassed event emission with nullifier, attribute_key, threshold, timestamp -- implemented
- CONT-06: verify_and_register with circuit_id routing (0=age, 1=membership) -- implemented
- CONT-07: Gas cost < 500K -- measured and documented (may need revision if exceeded)
- DEMO-04: Contracts deployed on Sepolia with addresses in deployments.json -- verified
</verification>

<success_criteria>
- StarkShieldRegistry deployed on Starknet Sepolia (visible on Starkscan)
- verify_and_register routes to correct verifier by circuit_id
- Nullifier replay protection works (same nullifier rejected on second use)
- Trusted issuer management works (add/remove by owner only)
- VerificationPassed events emitted and visible on Starkscan
- All three contract addresses recorded in deployments.json
- Gas cost documented (target: < 500K per CONT-07)
- snforge business logic tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-smart-contracts-deployment/04-02-SUMMARY.md`
</output>
